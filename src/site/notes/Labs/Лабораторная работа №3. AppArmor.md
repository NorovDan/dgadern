---
{"dg-publish":true,"permalink":"/labs/laboratornaya-rabota-3-app-armor/"}
---


---

**ФИО:** 2022-ФГиИБ-ИБ-1б Воронов Даниил Алексеевич 

---

### 1. Проверка _complain_ и _enforce_ режимов

**1.1. Создайте копию утилиты `ping` (из директории `/bin/`), а вместо нее скопируйте утилиту `cp` (`/bin/cp -> /bin/ping`). После этого переведите профиль `bin.ping` в режим `enforce`. Создайте в домашней директории файл и попробуйте его скопировать с помощью утилиты `ping` (которая, по факту, является копией утилиты `cp`).**

![Pasted image 20250302214108.png](/img/user/Pasted%20image%2020250302214108.png)
<div style="text-align: center;">
  Рисунок 1 - 
</div>

Создаём бэкап утилиты `ping`, чтобы потом вернуть её на место. З
Переводим профиль `bin.ping` в режим `enforce`посредством команды `sudo aa-enforce /etc/apparmour.d/bin.ping` Таким образом мы можем ограничивать нежелательные или же случайные ненужные действия приложений, предотвращая осуществление этих действий.
Создаём для теста файл, записываем в него  информацию, а после пытаемся подменённой утилитой `ping` скопировать файл целиком и сделать его новую копию, то мы получим ошибку, так как нет разрешения

Объясните, что произошло. Посмотрите журнал, что там за сообщения (относительно этой операции), что они значат?

![Pasted image 20250302214146.png](/img/user/Pasted%20image%2020250302214146.png)
<div style="text-align: center;">
  Рисунок 2 - Журнал логов
</div>

Логи находятся по пути `/var/log/syslog`
`requested_mask=r` - означает, что запрошено действия на чтение файла, `denied_mask=r` - означает запрет на чтение файла

**1.2. Переведите профиль `bin.ping` в режим `complain`. Повторите действия из шага 1.1. Что изменилось? Объясните. Какие теперь записи в журнале?**

![Pasted image 20250302214211.png](/img/user/Pasted%20image%2020250302214211.png)
<div style="text-align: center;">
  Рисунок 3 - Перевод bin.ping в режим complain
</div>

Перевод в данное состояние означает, что теперь можно выполнять действия, которые недоступны в режиме `enforce`. И теперь в журнале логов действия будут отображаться с пометкой `ALLOWED`

**1.3. Верните утилиту `ping` на свое место.**

![Pasted image 20250302214233.png](/img/user/Pasted%20image%2020250302214233.png)
<div style="text-align: center;">
  Рисунок 4 - Возвращаем утилиту на место
</div>


![Pasted image 20250302214256.png](/img/user/Pasted%20image%2020250302214256.png)
<div style="text-align: center;">
  Рисунок 5 -  Проверка ping
</div>

Проверяем, что утилита работа корректно


**1.4. Переведите профиль `bin.ping` в режим `enforce`. Попробуйте воспользоваться утилитов (из шага 1.1.) `my_ping`.**

![Pasted image 20250302221153.png](/img/user/Pasted%20image%2020250302221153.png)
<div style="text-align: center;">
  Рисунок 6 - Перевод bin.pin в режим enforce
</div>

Вновь переводим профиль в режим enforce. Снова пытаемся скопировать файл и у получаем ошибку

Объясните, что произошло. Посмотрите журнал, что там за сообщения (относительно этой операции)?

![Pasted image 20250302221209.png](/img/user/Pasted%20image%2020250302221209.png)
<div style="text-align: center;">
  Рисунок 7 - Проверка логов
</div>

Получаем такой же результат, как и в пункте 1.1
### 2. AppArmor на примере Docker

**2.1. Установите Docker**
Создайте группу `docker`, добавьте в нее своего пользователя. При необходимости перезагрузите систему.

![Pasted image 20250302221321.png](/img/user/Pasted%20image%2020250302221321.png)
<div style="text-align: center;">
  Рисунок 8 - Смотрит версию docker
</div>

Docker уже установлен в системе, так как он раньше требовался мне для работы

![Pasted image 20250302221333.png](/img/user/Pasted%20image%2020250302221333.png)
<div style="text-align: center;">
  Рисунок 9 - Создание группы docker
</div>

`sudo usermod -aG docker {user}` - позволяет установить возможность пользователю использовать docker без sudo. `-a` - добавляет пользователя в группу, `-G` - указывает группу

![Pasted image 20250302221343.png](/img/user/Pasted%20image%2020250302221343.png)
<div style="text-align: center;">
  Рисунок 10 - Проверка групп
</div>

Проверяем, что группы установилась корректно


**2.2. Создайте Docker-конетейнер с ubuntu:**

```
docker container run --rm -it --cap-add SYS_ADMIN --security-opt seccomp=unconfined ubuntu sh
```

![Pasted image 20250303002656.png](/img/user/Pasted%20image%2020250303002656.png)
<div style="text-align: center;">
  Рисунок 11 - Создание контейнера
</div>

Что значат ключи: - `--cap-add` - `seccomp=unconfined`
`--cap-add SYS_ADMIN` - даёт контейнеру доступ к ряду системных операций по типу монтирования файловой системы и тд;
`--security-opt seccomp=unconfined` - указывает контейнеру на получение доступа ко всем системным вызовам. 

Какой профиль **AppArmor** загружен?
![Pasted image 20250309185307.png](/img/user/Pasted%20image%2020250309185307.png)
<div style="text-align: center;">
  Рисунок 12 - Смотрим, что находится в enforce mode
</div>

Через `sudo aa-status` узнаем, что `docker-default` находится в `enforce mode`

Создайте два новых каталога (внутри контейнера), смонтируйте первый каталог в другой каталог (подробнее, `mount --bind`)
Что происходит?

![Pasted image 20250309185457.png](/img/user/Pasted%20image%2020250309185457.png)
<div style="text-align: center;">
  Рисунок 13 - Неудачная попытка смонтировать каталоги
</div>

Без `CAP_SYSLOG` процесс не может прочесть `dmesg`, так как просмотр логов `syslog` ядра ограничен. Попробуем устранить эту проблему добавлением при запуске контейнера флаг `--cap-add CAP_SYSLOG`.

![Pasted image 20250309190220.png](/img/user/Pasted%20image%2020250309190220.png)
<div style="text-align: center;">
  Рисунок 14 - Удачная попытка смонтировать каталоги
</div>
### 3. Пользовательский профиль AppArmor

**3.1. Скачайте материалы для ЛР из репозитория Docker:**

```
git clone https://github.com/docker/labs.git
cd labs/security/apparmor/wordpress
```

![Pasted image 20250309193401.png](/img/user/Pasted%20image%2020250309193401.png)
<div style="text-align: center;">
  Рисунок 15 - Переход в нужную директорию
</div>

**3.2. Опишите, какие контейнеры предлагается создать (docker-compose.yml). Создайте контейнеры с помощью docker-compose**

![Pasted image 20250309193558.png](/img/user/Pasted%20image%2020250309193558.png)
<div style="text-align: center;">
  Рисунок 15 - Содержание файла docker-compose.yml
</div>

При попытке запустить файл через docker compose up вылезают ошибки. Пришлось его исправлять


![Pasted image 20250309200616.png](/img/user/Pasted%20image%2020250309200616.png)
<div style="text-align: center;">
  Рисунок 16 - Запуск контейнера
</div>


**3.3. Проверьте работоспособность WordPress, выбрав язык и установив какие-либо плагины.**

![Pasted image 20250310182909.png](/img/user/Pasted%20image%2020250310182909.png)
<div style="text-align: center;">
  Рисунок 17 - Страница регистрации Wordpress
</div>

Wordpress находится по адресу http://localhost:8080

Все ли работает?

![Pasted image 20250310224809.png](/img/user/Pasted%20image%2020250310224809.png)
<div style="text-align: center;">
  Рисунок 18 - Включенный плагин
</div>

Все работает корректно

**3.4. Удалите созданные контейнеры.**

![Pasted image 20250310225351.png](/img/user/Pasted%20image%2020250310225351.png)
<div style="text-align: center;">
  Рисунок 19 - Удаление контейнера
</div>

**3.5. Добавьте wparmor профиль в файл конфигурации.**

Вставьте:

```
security_opt:
    - apparmor=wparmor
```

![Pasted image 20250310230017.png](/img/user/Pasted%20image%2020250310230017.png)
<div style="text-align: center;">
  Рисунок 20 - Содержание файла docker-compose.yml
</div>


Опишите правила в `wparmor`.

![Pasted image 20250310230127.png](/img/user/Pasted%20image%2020250310230127.png)
<div style="text-align: center;">
  Рисунок 21 - Содержание файла wparmor
</div>

- `#include <tunables/global>` - подключение глобальных переменных;
- `profile wparmor flags=(attach_disconnected,mediate_deleted)` - данные профили остаются активными даже после потери соединения с файловой системой, при этом контроль доступа продолжается даже для удалённых файлов;
- `#include <abstractions/base>` - импорт базовых профилей;
- `deny @{PROC}/* w,` - в данном случае, `{PROC}` является абстракцией, определенной посредством `<abstractions/base>`. В данном случае, она эквивалентна `/proc/`. То есть, эта строка предотвращает изменение файлов, расположенных прямо в `/proc`, но не затрагивает подкаталоги.
- `deny @{PROC}/{[^1-9],[^1-9][^0-9],[^1-9s][^0-9y][^0-9s],[^1-9][^0-9][^0-9][^0-9]*}/** w,` - запрещает запись в файлы и подкаталоги внутри `/proc`, за исключением тех, чьи имена состоят исключительно из цифр (т.е. идентификаторов процессов или же PID) или начинаются с "syslog", таким образом предотвращая изменение системных файлов в `/proc`, сохраняя возможность доступа к информации о процессах и системному журналу;
- `deny @{PROC}/sys/[^k]** w,` - запрещает запись во все подкаталоги внутри `/proc/sys/`, кроме тех, которые начинаются с буквы "k" (например, `/proc/sys/kernel`);
- `deny @{PROC}/sys/kernel/{?,??,[^s][^h][^m]**} w,` - запрещает запись в файлы и подкаталоги внутри `/proc/sys/kernel/`, за исключением тех, чьи имена начинаются с "shm" (например, `shmall`, `shmmax`);
- `deny @{PROC}/sysrq-trigger rwklx,` - полностью запрещает любые операции (чтение, запись, выполнение, блокировка) с файлом `/proc/sysrq-trigger`, который отвечает за отправку команд аварийного восстановления системе;
- `deny @{PROC}/mem rwklx,` - запрет предотвращает чтение или модификацию содержимого оперативной памяти, обеспечивая безопасность системы;
- `deny @{PROC}/kmem rwklx,` - предотвращает возможность чтения или изменения данных ядра;
- `deny @{PROC}/kcore rwklx,` - предотвращает возможность чтения или модификации содержимого памяти ядра;
- `deny mount` и `deny unmount` - блокировка монтирования и размонтирования каталогов;
- `deny /sys/[^f]*/** wklx,` - запрет на запись различных системных параметров;
- `deny /sys/firmware/efi/efivars/** rwklx,` - предотвращение изменение UEFI;
- `deny /sys/kernel/security/** rwklx,` - предотвращение изменения политики безопасности;
- `deny /var/www/html/* wlx,`, `deny /var/www/html/wp-admin/** wlx,`, `deny /var/www/html/wp-includes/** wlx,`, `deny /var/www/html/wp-content/* wlx,` - запрет изменения файлов для WordPress, за исключением подкаталогов `wp-content`.
- `ptrace (trace,read) peer=docker-default,` - специальное разрешение для Docker'а, позволяющее просмотреть процессы внутри контейнера;
- `signal (receive) set=(kill,term) peer=/usr/bin/docker,` - специальное разрешает управлять контейнерами.

**3.6. Отредактируйте файл wparmor так, чтобы запретить использование каталогов в `var/www/html/wp-content` за исключением директории `uploads`. _Спарсите_ новый файл (`apparmor_parse`).**

![Pasted image 20250311003647.png](/img/user/Pasted%20image%2020250311003647.png)
<div style="text-align: center;">
  Рисунок 22 - Изменение файла wparmor
</div>


![Pasted image 20250311003836.png](/img/user/Pasted%20image%2020250311003836.png)
<div style="text-align: center;">
  Рисунок 23 - Парсим новый файл
</div>


**3.7. Повторите шаги 3.2. и 3.3. и опишите результат.**

Можете ли вы устанавливать плагины и загружать другой контент?

![Pasted image 20250311004157.png](/img/user/Pasted%20image%2020250311004157.png)
<div style="text-align: center;">
  Рисунок 24 - Неудачная попытка установить плагин
</div>

Конфигурацией профиля `wparmor` запрещена запись и изменение объектов в каталоге `/wp-content` и `/wp-admin`, мы не можем устанавливать и активировать плагины и т.д. 

### 4. Пользовательский профиль AppArmor произвольного приложения

**4.1. Выберите произвольное приложение с открытым исходным кодом (приложение может сразу поставляться в виде docker-образа или вы можете создать образ самостоятельно). Приложение должно быть подобрано таким образом, чтобы было удобно настроить политику AppArmor для него. Разверните приложение, опишите процесс выполнения развертывания.**

Было выбрано приложение GoSƐ 
GoSƐ - это современный и масштабируемый загрузчик файлов, ориентированный на масштабируемость и простоту.

![Pasted image 20250317230439.png](/img/user/Pasted%20image%2020250317230439.png)
<div style="text-align: center;">
  Рисунок 25 - Запуск контейнера
</div>

Приложение будет находится по адресу http://localhost:8080

![Pasted image 20250317230513.png](/img/user/Pasted%20image%2020250317230513.png)
<div style="text-align: center;">
  Рисунок 26 - Страница приложения
</div>


**4.2. Придумайте и опишите политику AppArmor, продемонстрируйте ее работу.**

![Pasted image 20250317232718.png](/img/user/Pasted%20image%2020250317232718.png)
<div style="text-align: center;">
  Рисунок 27 - Создание и редактирование файла политики AppArmor
</div>

Содержание файла docker-gose: 
```
#include <tunables/global>  
  
/etc/gose/** r,  
# Разрешаем чтение всех файлов в директории GoSƐ  
/etc/gose/* r,  
  
# Разрешаем выполнение файлов в директории GoSƐ  
/etc/gose/** px,  
  
# Разрешаем доступ к системным библиотекам и бинарникам  
/usr/lib/** r,  
# Чтение системных библиотек и бинарников  
/lib/** r,  
  
# Доступ к сети для взаимодействия с S3  
network inet stream,  
# Разрешаем доступ к TCP/UDP-соединениям для работы с интернетом  
  
# Применяем политику, чтобы Gose не имел доступ к чувствительным данным и системным путям  
/boot/** r,  
# Ограничиваем доступ к загрузочным файлам  
  
# Доступ к временным файлам, если GoSƐ использует их  
/tmp/** rw,  
# Разрешаем запись и чтение во временную директорию  
  
# Логирование ошибок или других данных  
/var/log/gose.log rw,  
# Логирование в файл gose.log в /var/log, если это необходимо  
  
# Запрещаем доступ к домашним директориям  
/home/** deny,  
# Запрещаем доступ ко всем домашним директориям пользователей  
  
# Запрещаем доступ к устройствам хранения данных, если это не нужно  
/dev/** deny,  
# Полный запрет на доступ к устройствам, если не используется специфическое оборудование  
  
# Пример разрешений для файловой системы (если GoSƐ работает с локальными файлами)  
# Разрешаем чтение файлов из директорий, с которыми GoSƐ может работать локально  
/var/uploads/** rw,  
# Если GoSƐ использует локальное хранилище для промежуточных файлов, разрешаем доступ  
  
# Разрешение на работу с конфигурационными файлами  
/etc/gose/config.yaml r,  
# Разрешаем чтение конфигурационного файла приложения (если он существует)  
  
# Разрешение на работу с внешними S3 хранилищами (если указывается в конфигурации)  
# Сеть может быть использована для взаимодействия с удаленным S3  
network inet dgram,  
```

Давайте разберем политику AppArmor для приложения GoSƐ по каждой строке:

1. **`#include <tunables/global>`**

- Это директива подключения глобальных настроек, которые могут быть определены в других файлах, обычно для настройки общей безопасности или политик для всех приложений.

 2. **`/etc/gose/** r,`**

- Разрешает приложению GoSƐ читать все файлы в каталоге `/etc/gose` и его подкаталогах. Это важно для доступа к конфигурационным файлам, которые могут находиться в этом каталоге.

3. **`/etc/gose/* r,`**

- Подобное разрешение для файлов в каталоге `/etc/gose` без подкаталогов. Оно разрешает только чтение файлов в данном каталоге (не в подкаталогах).

 4. **`/etc/gose/** px,`**

- Разрешает выполнение всех файлов в каталоге `/etc/gose` и его подкаталогах. Это может быть полезно, если GoSƐ требует выполнения скриптов или других исполняемых файлов, расположенных в этом каталоге.

 5. **`/usr/lib/** r,`**

- Разрешает чтение файлов в каталоге `/usr/lib` и его подкаталогах. Это важно для того, чтобы приложение могло читать системные библиотеки.

 6. **`/lib/** r,`**

- Разрешает чтение системных библиотек, расположенных в каталоге `/lib` и его подкаталогах.

 7. **`network inet stream,`**

- Разрешает GoSƐ использовать сокеты для установления TCP-соединений, что важно для сетевого взаимодействия с другими сервисами (например, для общения с S3 через HTTP/HTTPS).

 8. **`/boot/** r,`**

- Ограничивает доступ к каталогу `/boot`, который часто содержит загрузочные файлы. Это разрешение позволяет только чтение файлов в этом каталоге, чтобы предотвратить изменение конфигурации загрузки.

 9. **`/tmp/** rw,`**

- Разрешает приложению GoSƐ читать и записывать в каталог `/tmp`, который используется для временных файлов. Это необходимо, если приложение использует временные файлы для работы.

 10. **`/var/log/gose.log rw,`**

- Разрешает GoSƐ читать и записывать в файл журнала `/var/log/gose.log`. Это разрешение нужно для того, чтобы приложение могло логировать свои ошибки или другую информацию.

 11. **`/home/** deny,`**

- Запрещает доступ к домашним каталогам пользователей (`/home`). Это предотвращает доступ GoSƐ к личным данным пользователей, что повышает безопасность.

 12. **`/dev/** deny,`**

- Запрещает доступ к устройствам, расположенным в каталоге `/dev`. Это предотвратит доступ GoSƐ к важным системным устройствам, таким как диски, порты и другие устройства, если они не используются приложением.

13. **`/var/uploads/** rw,`**

- Разрешает GoSƐ читать и записывать файлы в директории `/var/uploads`. Это может быть полезно, если приложение использует локальное хранилище для хранения промежуточных файлов.

 14. **`/etc/gose/config.yaml r,`**

- Разрешает чтение файла конфигурации приложения GoSƐ (если он существует). Этот файл может содержать параметры, такие как настройка взаимодействия с S3 или другими сервисами.

 15. **`network inet dgram,`**

- Разрешает GoSƐ использовать сокеты для передачи данных через протокол UDP (datagram), что может быть необходимо для сетевого взаимодействия, например, с удаленными хранилищами данных, такими как S3.

![Pasted image 20250317233232.png](/img/user/Pasted%20image%2020250317233232.png)
<div style="text-align: center;">
  Рисунок 28 - Разблокируем нашу политику
</div>

Добавляем в `compose.yaml` строчку, которая позволяет нам задействовать нашу политику:
```
security_opt:
- apparmor=docker-gose
- 
```

![Pasted image 20250323211712.png](/img/user/Pasted%20image%2020250323211712.png)
<div style="text-align: center;">
  Рисунок 29 - Работа политики
</div>

Пытаемся прочесть содержимое  домашней директории и получаем ошибку. Это означает, что наша политика безопасности действительно работает